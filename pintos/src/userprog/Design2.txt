		           +--------------------------+
				   |         CIS 520          |
		           | PROJECT 2: USER PROGRAMS |
		           |     DESIGN DOCUMENT      |
		           +--------------------------+

---- GROUP ----

>> Fill in the names of your group members.

Dalton Hahn
Lane Evans
Olivia Baalman

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

Passing 75/80 test cases
  FAIL tests/filesys/base/syn-write
  FAIL tests/filesys/base/syn-read
  FAIL tests/userprog/rox-child
  FAIL tests/userprog/rox-multichild
  FAIL tests/userprog/exec-arg

Inspired by https://github.com/codyjack/OS-pintos



			   ARGUMENT PASSING
			   ================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.


pintos/src/threads/thread.c
  t->parent = thread_current(): a new thread that a parent thread creates and initializes t’s parent to the current thread

pintos/src/userprog/process.c
  Added char *file_name to static bool setup_stack (void **esp, char * file_name) to assign the name to the user space stack

pintos/src/threads/thread.h
  struct child_status: the return status of the child thread
  tid parent_id: store the id of the parent thread

pintos/src/userprog/exception.c
  static void exit(int): to properly exit threads that throw an exception


---- ALGORITHMS ----

>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?
>> How do you avoid overflowing the stack page?

We implement argument passing in process.c.  Here, the setup_stack method takes a pointer to the stack and the file_name.  
Arguments and the command name, for example “echo”, are pushed to the stack.  We loop through the command string to 
parse the arguments of the full string and pushe their reference onto the stack.  Overflows are avoided because 
we continuously push down the “total_length” parameter toget accurate page sizes.



---- RATIONALE ----

>> A3: Why does Pintos implement strtok_r() but not strtok()?

“_r” functions are reentrant, meaning they are thread-safe.  For parallel/multiprogramming applications such as an 
operating system, these types of functions are very useful.

>> A4: In Pintos, the kernel separates commands into an executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least two advantages of the Unix approach.

The Unix approach lifts the burden of parsing and dealing with the command string from the kernel to the shell.  
This frees the kernel from unnecessary executions and actions to be taken.  Also, by abstracting this 
functionality to the shell, you keep your kernel code compact, clean, and efficient for other tasks.


			     SYSTEM CALLS
			     ============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

pintos/src/userprog/syscall.c
  struct lock fs_lock: Created a lock around access to the filesystem.
  struct list open_file: List of open files belonging to user programs.
  struct file_descriptor: The purpose of this was to store a description for a file including which number; the the thread id owner; a pointer to the file and a list element. 

pintos/src/userprog/syscall.h 
  typedef int pid_t: To add the thread process ID number


>> B2: Describe how file descriptors are associated with open files.
>> Are file descriptors unique within the entire OS or just within a
>> single process?

Our file descriptors are unique within the entire pintos OS.  Through our open file list, we can track which files are open as 
well as who their owners are.  This allows multiple user processes to be accessing and manipulating files at one point 
in time without collisions.  Our file descriptors are associated with this open file list through a file descriptor id 
that is a part of our syscall.c implementation.

---- ALGORITHMS ----

>> B3: Describe your code for reading and writing user data from the
>> kernel.

The read method checks the bounds of the buffer to ensure valid pointers within user space.  
It also checks the file descriptor number to see if the user is trying read from stdout, read 
from stdin, or read from a file.  If reading from standard out, we return -1 indicating 
an error. If reading from stdin, we acquire the lock and read into a buffer until there 
is no more input.  If reading from a file, we acquire the lock, read the file, release 
the lock and return the status of the operation.

As for write, we check the validity of the bounds of the buffer. If writing to stdin, return -1 
to identify an error. Otherwise, if writing stdout, then call the putbuf function with the 
content user is writing and return the size. Lastly, if writing to a file, acquire file lock 
and write the information to the file. The release file lock and return status.


>> B4: Suppose a system call causes a full page (4,096 bytes) of data
>> to be copied from user space into the kernel.  What is the least
>> and the greatest possible number of inspections of the page table
>> (e.g. calls to pagedir_get_page()) that might result?  What about
>> for a system call that only copies 2 bytes of data?  Is there room
>> for improvement in these numbers, and how much?

The least number of inspections of the page table would be 1 in the case where the inspection 
of the page table results in a hit of the beginning of the contiguous block of 4096 bytes.  
The greatest number would be 2 in the case that the inspection of the page table results in a 
hit that is not at the beginning of the block of bytes.  In this case, a second inspection of 
the page table would be necessary to locate the beginning of the block of memory.  With 2 bytes 
of data, the least number would be 1 in the case where the inspection of the page table results 
directly in access to the beginning of the 2 byte chunk.  The greatest number would be 2 in the 
case that the inspection to the page table results in an access of the two bytes of memory but 
not at the beginning of the contiguous chunk.  We feel that there is not much room to improve 
these access numbers.

>> B5: Briefly describe your implementation of the "wait" system call
>> and how it interacts with process termination.

Check to see if child id is valid and if so, add the child id to the current thread’s list 
of children.  Acquire the lock and wait until child is done executing.  Record the child’s 
execution status in the parent, release the lock.  The parent will always wait for the child 
to terminate before continuing its own execution.  The parent is also responsible for returning 
the child’s status.

>> B6: Any access to user program memory at a user-specified address
>> can fail due to a bad pointer value.  Such accesses must cause the
>> process to be terminated.  System calls are fraught with such
>> accesses, e.g. a "write" system call requires reading the system
>> call number from the user stack, then each of the call's three
>> arguments, then an arbitrary amount of user memory, and any of
>> these can fail at any point.  This poses a design and
>> error-handling problem: how do you best avoid obscuring the primary
>> function of code in a morass of error-handling?  Furthermore, when
>> an error is detected, how do you ensure that all temporarily
>> allocated resources (locks, buffers, etc.) are freed?  In a few
>> paragraphs, describe the strategy or strategies you adopted for
>> managing these issues.  Give an example.

We chose to abstract out the validation of pointers and addresses to a function that we could 
call throughout our program.  By having this function in a location where we could call it 
from various points, we ensured to the user that the accesses they were making in memory 
were valid and would not cause kernel panics / issues further in the code.  When we generate 
an exit syscall on bad user accesses or invalid pointers, we choose to free all of our 
resources at that point so that no memory is leaked.  For example, whenever a system call is 
made from user space, before any of the system calls are executed, we check all of the pointers 
associated with the generated system call.  If any of them correspond to an invalid memory 
access or memory not owned by the user process, the request is cancelled and the resources 
allocated to the process are freed.

---- SYNCHRONIZATION ----

>> B7: The "exec" system call returns -1 if loading the new executable
>> fails, so it cannot return before the new executable has completed
>> loading.  How does your code ensure this?  How is the load
>> success/failure status passed back to the thread that calls "exec"?

We use synchronization tools like locks and condition variables in order to “hold” the execution 
of the rest of the system until the loading of the new executable has either failed or reached 
a successful state.  The success/failure status of the system call is passed back to the 
thread that calls it through the EAX register.  By saving that out onto the stack other threads 
have access to this information and can inform other portions of the system of a failure/success 
regarding the opening of an executable file.

>> B8: Consider parent process P with child process C.  How do you
>> ensure proper synchronization and avoid race conditions when P
>> calls wait(C) before C exits?  After C exits?  How do you ensure
>> that all resources are freed in each case?  How about when P
>> terminates without waiting, before C exits?  After C exits?  Are
>> there any special cases?

We ensure proper synchronization and avoid race conditions through our implementation 
of locks and waiting statuses across children and parent processes.  When a parent 
process calls wait(C) on a child process, the child is locked and put in a waiting 
state.  This status is updated within the parent process and is tracked until the 
child process completes execution.  We ensure that all resources are freed in each 
case through our call to process_exit and the cleaning of resources in that function.

  P terminates without waiting: When P exits, the lock on the child process is freed 
    and the child can continue to execute until completion.
  After C exits: the child process updates its status within the parent process 
    and then the resources are freed just like a standard call to process_exit.


---- RATIONALE ----

>> B9: Why did you choose to implement access to user memory from the
>> kernel in the way that you did?

In order to store out relevant data from the command string passed on the command 
line, we chose to implement access and storage into user memory using the stack.  
First, we allocate a page in memory for the user stack.  Then, by passing the entire 
command string to the user memory block, we can parse and manipulate the string in 
order to store the relevant information in a way that user programs can access memory 
and perform the functions necessary.  We felt that the stack structure and direct 
passing of the full command string simplified the necessary steps we would need to 
take in order to pass information back and forth between kernel and user space.


>> B10: What advantages or disadvantages can you see to your design
>> for file descriptors?

Our design of the file descriptor structure is advantageous because we are storing 
small amounts of data regarding each of the open files.  Within the file_descriptor 
structure we track the owner of the file to avoid accesses that other programs may 
be attempting to make on that open file. Also, we allow owner processes to hold multiple 
files in case they are needing access to multiple files throughout their execution.  
We achieve this through a list of file_descriptor elements.  Also, we are able to keep 
track of all open file descriptors through a list of all open files.


>> B11: The default tid_t to pid_t mapping is the identity mapping.
>> If you changed it, what advantages are there to your approach?

We did not modify this mapping. 



			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

I feel like this assignment in general is too difficult.  I feel that all three of the
compoenents are extremely challenging.  This took vastly too much time for
a three credit hour course assignment.

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?

I feel that the assignments do not accurately correspond to the lecture material.  
I understand that the class in general is very difficult to implement at an 
undergraduate level, but I feel that the class would benefit greatly from implementing 
“modules” rather than homework assignments that attempt to cover, in my opinion, 
large portions of an operating system at one point.  I feel like by separating 
concepts into weekly modules, not only would students benefit more on the conceptual 
side, but also in their ability to implement smaller portions and better understand 
what is happening.  
